import { ProvisioningArtifactOutputs, ProvisioningArtifactParameters } from 'aws-sdk/clients/servicecatalog';
import { pascal, camel, constant } from 'case';
import * as j2j from 'json2jsii';
import { ProductDataAggregate } from './service-catalog';

/**
 * Represents an enum for CloudFormation parameter inputs that have predefined allowed values.
 */
type EnumDefinition = {
  name: string;
  allowedValues: string[];
};

/**
 * Generator to emit classes and information on provisioning details for a product.
 */
export class ServiceCatalogProvisioningConstructGenerator {
  private readonly productDataAggregate: ProductDataAggregate;
  private readonly hasParameters: boolean;
  private readonly sanitizedTypeName: string;
  private readonly resourceAttributes: string[];
  private readonly constructClassName: string;
  private readonly propsStructName: string;
  private readonly enums: EnumDefinition[];
  private readonly parameters: ProvisioningArtifactParameters;
  private readonly defaultAttributes: Set<string>;
  private readonly outputKeys: ProvisioningArtifactOutputs;
  private readonly outputDescriptions: {[key: string]: string | undefined};
  public readonly name: string;

  /**
   * @param productData the aggregate details on a product with information on inputs and outputs of the template.
   */
  constructor(productData: ProductDataAggregate) {
    this.productDataAggregate = productData;
    this.sanitizedTypeName = pascal(this.productDataAggregate.product.Name!);
    this.constructClassName = j2j.TypeGenerator.normalizeTypeName(this.sanitizedTypeName);
    this.propsStructName = j2j.TypeGenerator.normalizeTypeName(`${this.constructClassName}Props`);
    this.name = this.sanitizedTypeName;
    this.resourceAttributes = new Array<string>();
    this.enums = new Array<EnumDefinition>();
    this.parameters = this.productDataAggregate.params.ProvisioningArtifactParameters!;
    this.hasParameters = this.productDataAggregate.params.ProvisioningArtifactParameters!.length > 0;
    this.outputKeys = this.productDataAggregate.params.ProvisioningArtifactOutputKeys!;
    this.outputDescriptions = this.productDataAggregate.params.ProvisioningArtifactOutputKeys!.reduce((obj, key) => {
      obj[camel(key.Key!)] = key.Description;
      return obj;
    }, {} as {[key: string]: string | undefined});

    this.defaultAttributes = new Set<string>(['provisionedProductId', 'cloudFormationStackArn', 'recordId']);

    this.resourceAttributes.push(
      ...this.defaultAttributes,
      ...this.outputKeys.map(key => camel(key.Key!)),
    );
  }

  /**
   * Render the type into a TypeScript class file defining the props and the wrapped L1 construct AWS::ServiceCatalog::CloudFormationProvisionedProduct.
   *
   * @returns the rendered class file content
   */
  public render(): string {
    const code = new j2j.Code();
    this.emitImports(code);
    this.emitInterface(code);
    this.emitBase(code);
    if (this.hasParameters) {
      this.emitParameterMap(code);
      this.emitDefinitionTypes(code);
    }
    this.emitConstructClass(code);
    this.enums.length && this.emitEnums(code);
    return code.render();
  }

  private emitImports(code: j2j.Code) {
    code.line('// Generated by cdk-import');
    code.line("import * as cdk from 'aws-cdk-lib';");
    code.line("import * as constructs from 'constructs';");
    code.line("import * as sc from 'aws-cdk-lib/aws-servicecatalog';");
    code.line();
  }

  private emitInterface(code: j2j.Code) {
    code.openBlock(`export interface I${this.constructClassName} extends cdk.IResource`);
    this.resourceAttributes.forEach(attr => {
      code.line(`readonly ${attr}: string;`);
    });
    code.closeBlock();
    code.line();
  }

  private emitBase(code: j2j.Code) {
    code.openBlock(`abstract class ${this.constructClassName}Base extends cdk.Resource implements I${this.constructClassName}`);
    this.resourceAttributes.forEach(attr => {
      code.line(`public abstract readonly ${attr}: string;`);
    });
    code.closeBlock();
    code.line();
  }

  private emitParameters(code: j2j.Code) {
    code.line('  provisioningParameters:');
    code.line('    Object.entries(props).map(([k, v]) => {');
    code.line('      return {');
    code.line('        key: ParameterKeys.valueOf(k) as string,');
    code.line('        value: v as string,');
    code.line('      }');
    code.line('    }),');
  }

  private emitParameterMap(code: j2j.Code) {
    code.openBlock('enum ParameterKeys');
    this.parameters?.forEach(p => {
      code.line(`${camel(p.ParameterKey!)} = '${p.ParameterKey}',`);
    });
    code.closeBlock();
    code.line();
    code.openBlock('namespace ParameterKeys');
    code.line('const reverseMap = new Map<string, ParameterKeys>();');
    code.line('Object.keys(ParameterKeys).forEach((s: string) => {');
    code.line('  const e = (<any>ParameterKeys)[s];');
    code.line('  reverseMap.set(s, e);');
    code.line('});');
    code.line('export function valueOf(str: string) {');
    code.line('  return reverseMap.get(str);');
    code.line('}');
    code.closeBlock();
  }

  private emitDefinitionTypes(code: j2j.Code) {
    code.openBlock(`export interface ${this.constructClassName}Props`);
    this.parameters!.forEach(pa => {
      let optional = '';
      code.line('/**');
      code.line(` * ${pascal(pa.ParameterKey!)}`);
      if (pa.Description) {
        code.line(' *');
        code.line(` * ${pa.Description}`);
      }
      if (pa.ParameterConstraints?.ConstraintDescription) {
        code.line(' *');
        code.line(` * ${pa.ParameterConstraints?.ConstraintDescription}`);
      }
      if (pa.DefaultValue) {
        optional += '?';
        code.line(' *');
        code.line(` * @default ${pa.DefaultValue}`);
      }
      if (pa.ParameterConstraints?.AllowedValues?.length) {
        this.enums.push({
          name: pa.ParameterKey!,
          allowedValues: pa.ParameterConstraints.AllowedValues,
        });
      };

      code.line(' */');
      code.line(`readonly ${camel(pa.ParameterKey!)}${optional}: ${pa.ParameterConstraints?.AllowedValues?.length ? this.constructClassName + '.' + pa.ParameterKey : 'string'};`);
      code.line();
    });
    code.closeBlock();
  }

  private resolveEnumValue(val: string): string {
    if (Number(val)) {
      return constant(`VALUE_${val}`);
    } else if (Number(val.charAt(0))) {
      return `'${constant(val)}'`;
    } else {
      return constant(val);
    }
  }

  private emitEnums(code: j2j.Code) {
    code.line();
    code.openBlock(`export namespace ${this.constructClassName}`);
    this.enums.forEach( e => {
      code.line();
      code.openBlock(`export enum ${e.name}`);
      e.allowedValues.forEach(val => {
        code.line('/**');
        code.line(` * ${val}`);
        code.line(' */');
        code.line(`${this.resolveEnumValue(val)} = '${val}',`);
        code.line();
      });
      code.closeBlock();
      code.line();
    });
    code.closeBlock();
    code.line();
  }

  private emitProductDescription(code: j2j.Code) {
    const product = this.productDataAggregate.product;
    code.line('/**');
    code.line(` * ${this.sanitizedTypeName}`);
    code.line(' *');
    if (product.ShortDescription) {
      code.line(` * ${product.ShortDescription}`);
      code.line(' *');
    }
    product.SupportDescription && code.line(` * ${product.SupportDescription}`);
    product.SupportEmail && code.line(` * Support Email: ${product.SupportEmail}`);
    product.SupportUrl && code.line(` * Support Url: ${product.SupportUrl}`);
    product.Distributor && code.line(` * Distributor: ${product.Distributor}`);
    product.Owner && code.line(` * Owner: ${product.Owner}`);
    code.line(' */');
  }

  private emitConstructClass(code: j2j.Code) {
    this.emitProductDescription(code);
    code.openBlock(`export class ${this.constructClassName} extends ${this.constructClassName}Base`);
    for (const prop of this.resourceAttributes) {
      if (this.outputDescriptions[prop]) {
        code.line('/**');
        code.line(` * ${this.outputDescriptions[prop]}`);
        code.line(' */');
      }
      code.line(`public readonly ${prop}: string;`);
    }
    code.line('private readonly provisionedProduct: sc.CfnCloudFormationProvisionedProduct;');
    code.line();

    code.line('/**');
    code.line(` * Create a new Service Catalog \`${this.sanitizedTypeName}\` product.`);
    code.line(' *');
    code.line(' * @param scope - scope in which this resource is defined');
    code.line(' * @param id    - scoped id of the resource');
    if (this.hasParameters) {
      code.line(' * @param props - resource properties');
    }
    code.line(' */');
    code.openBlock(`constructor(scope: constructs.Construct, id: string${this.hasParameters ? ', props: ' + this.propsStructName : ''})`);
    code.line('super(scope, id);');
    code.line('');
    code.line("this.provisionedProduct = new sc.CfnCloudFormationProvisionedProduct(this, 'Resource', {");
    code.line('  provisionedProductName: this.node.id,');

    if (this.productDataAggregate.provisioningArtifact.Name) {
      code.line(`  provisioningArtifactName: '${this.productDataAggregate.provisioningArtifact.Name!}',`);
    } else {
      code.line(`  provisioningArtifactId: '${this.productDataAggregate.provisioningArtifact.Id!}',`);
    }

    if (this.productDataAggregate.product.Name) {
      code.line(`  productName: '${this.productDataAggregate.product.Name!}',`);
    } else {
      code.line(`  productId: '${this.productDataAggregate.product.ProductId!}',`);
    }

    if (this.productDataAggregate.launchPath.Name) {
      code.line(`  pathName: '${this.productDataAggregate.launchPath.Name!}',`);
    } else {
      code.line(`  pathId: '${this.productDataAggregate.launchPath.Id!}',`);
    }

    // generate provisioning parameters from props to avoid redundant defaults
    if (this.hasParameters) {
      this.emitParameters(code);
    }

    code.line('});');
    code.line();
    code.line('this.provisionedProductId = this.provisionedProduct.ref;');
    code.line("this.cloudFormationStackArn = cdk.Token.asString(cdk.Fn.getAtt(this.provisionedProduct.logicalId, 'CloudformationStackArn'));");
    code.line("this.recordId = cdk.Token.asString(cdk.Fn.getAtt(this.provisionedProduct.logicalId, 'RecordId'));");
    this.outputKeys?.forEach(output => {
      code.line(`this.${camel(output.Key!)} = cdk.Token.asString(cdk.Fn.getAtt(this.provisionedProduct.logicalId, 'Outputs.${output.Key!}'));`);
    });
    code.closeBlock();

    // Close construct class
    code.closeBlock();
  }
}
